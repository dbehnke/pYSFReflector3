# Runtime Risk Plan — pYSFReflector3

This document captures the results of a static runtime-risk scan of `YSFReflector` and recommends prioritized mitigations. We'll use this as the working plan for future sessions.

## Summary
I scanned the main file `YSFReflector` for patterns likely to cause runtime failures (race conditions, incorrect function usage, unguarded operations, and potential exceptions). The list below is prioritized by severity and ease of fix.

---

## High-risk issues (action recommended before production)

1) Concurrent mutation while iterating (list removal)
- Where: `TimeoutNodi`, `TimeoutNodiJS`, `homedb`, `json_recv`, `TimeoutTX`, `ckeck_wild_ptt`, `scheduler`, and others.
- Why risky: Removing items from a list while iterating can skip items or raise runtime errors. When lists are shared between threads this becomes a race.
- Fix: Iterate over a copy (e.g., `for x in lst[:]`) or collect removals and apply after the loop. Use locks when lists are shared across threads.

2) Unprotected shared state (missing locks / inconsistent locking)
- Where: `clients`, `SCHED`, `BLK_TMP`, `W_PTT`, `APRS_LH`, and the internals of `client_manager` and `stream_manager`.
- Why risky: Race conditions leading to corrupted state or inconsistent reads.
- Fix: Add specific locks (e.g., `lock_clients`, `lock_sched`) and always acquire them around read/write. For read-mostly workloads, consider atomic list replacement or R/W locks.

3) `.remove()` calls that may raise ValueError
- Where: `BLK_TMP.remove(sc[0])`, `SCHED.remove(sc)`, `r_lock.remove(d)`, map/list index removals in `ClientLookup` and `StreamManager`.
- Why risky: In races the item may already be removed, causing ValueError.
- Fix: Wrap in `try/except ValueError: pass` or use `set.discard()` for set semantics.

4) Broad excepts hiding real errors
- Where: many `except:` and `except Exception:` blocks across the codebase.
- Why risky: Swallows tracebacks, hides root causes.
- Fix: Catch specific exceptions; log full traceback for unexpected exceptions.

5) UnicodeDecodeError from `.decode()` on network bytes
- Where: many `.decode()` calls like `data[4:14].decode().strip()`.
- Why risky: Invalid bytes can raise UnicodeDecodeError.
- Fix: Use `decode('utf-8', errors='replace')` or handle decode errors explicitly.

6) Blocking DNS in blacklist reload
- Where: `socket.gethostbyname()` inside `blacklist` reload loop.
- Why risky: DNS may be slow or blocked, causing the reload thread to stall.
- Fix: Use threadpool/async resolution or cache results and resolve at startup.

7) Indexing raw lists without shape guarantees
- Where: uses of `tx[...]`, `entry[3]` for APRS entries, etc.
- Why risky: IndexError if data doesn't match expected shape.
- Fix: Use dataclasses or small helper accessors that perform `len()` checks.

---

## Medium-risk issues

- Redundant `file.close()` after `with SafeFileHandler(...)` — cleanup, low risk.
- `printlog_orig` used before `filelog` is fully configured — handled with try/except but note it.
- Potential unbounded growth of some lists/queues (e.g., `SCHED`, `json_mess`) — add caps or eviction.
- Using `queue.Queue` without maxsize may cause memory growth; consider `maxsize` or drop policies.

---

## Low-risk / Nice-to-have improvements
- Replace raw list record structures with `@dataclass` or `namedtuple` for clients and streams.
- Use `json.dumps()` for JSON messages instead of manual concatenation.
- Add unit tests for `FastLookupManager`, `ClientLookup`, and `StreamManager` (happy path + edge cases).
- Add structured logging (thread id, JSON) and health metrics.

---

## Immediate low-risk fixes I recommend implementing now
1. Replace in-loop removals with safe patterns (iterate over a shallow copy) across the file.
2. Add `try/except ValueError` for `list.remove()` calls.
3. Use safe decoding for network bytes: `.decode('utf-8', errors='replace')`.
4. Remove redundant `file.close()` after `with` contexts.
5. Add `maxsize` to high-rate queues (e.g., `json_mess`, `recvPackets`) or make producers non-blocking with fallback.

I can apply these low-risk fixes now and run quick syntax checks and smoke tests. If you'd like to proceed in this session, tell me which fixes to apply first.

---

## Follow-ups for a later session
- Add locks and migrate strategic shared data to lock-protected code paths.
- Refactor clients/streams into dataclasses and update code accordingly.
- Add unit tests and CI checks.
- Add runtime monitoring/metrics and structured logging.


*Generated by a static analysis pass. This plan is intended to be actionable and to guide safe incremental fixes.*
